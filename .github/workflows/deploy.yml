# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
# This workflow will build a Java project with Gradle and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-gradle

name: Deploy Frontend + Backend (Docker)

on:
  push:
    branches: ["main"]
    paths:
      - "frontend/novels/**"
      - "backend/novels/**"
      - ".github/workflows/deploy.yml"

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ---------- Frontend (Vite) ----------
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: "**/package-lock.json"

      - name: Install frontend deps
        working-directory: frontend/novels
        run: |
          npm ci
          npm run build

      # ---------- Backend (Spring Boot) ----------
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "17"
          cache: "gradle"

      # gradlew 실행 권한 부여
      - name: Make gradlew executable
        working-directory: backend/novels
        run: |
          chmod +x gradlew
          ./gradlew clean build -x test

      # ---------- Prepare artifacts ----------
      - name: Prepare artifacts
        run: |
          mkdir -p artifacts/frontend artifacts/backend

          # frontend dist
          cp -r frontend/novels/dist/* artifacts/frontend/

          # backend jar -> app.jar (plain.jar 제외)
          JAR_PATH=$(ls backend/novels/build/libs/*.jar | grep -v -- '-plain\.jar' | head -n 1)
          if [ -z "$JAR_PATH" ]; then
            echo "No runnable jar found in novels/backend/build/libs"
            ls -al backend/novels/build/libs || true
            exit 1
          fi

          cp "$JAR_PATH" artifacts/backend/app.jar
          cp backend/novels/Dockerfile artifacts/backend/Dockerfile
          cp backend/novels/docker-compose.yml artifacts/backend/docker-compose.yml

      # ---------- SSH + Rsync ----------

      - name: Install ssh + rsync
        run: sudo apt-get update && sudo apt-get install -y openssh-client rsync

      - name: Start ssh-agent and add key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SERVER_SSH_RSA }}

      # 호스트 키 등록
      - name: Add Remote Host to Known Hosts
        run: |
          # 1. .ssh 디렉토리가 없으면 생성 (이미 있으면 무시)
          mkdir -p ~/.ssh

          # 2. 알려진 호스트 파일이 없으면 생성 및 권한 설정
          touch ~/.ssh/known_hosts

          # 3. ssh-keyscan 실행 
          ssh-keyscan -p ${{ secrets.SERVER_PORT }} -t rsa ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts || true

          # 4. 권한 보안 설정
          chmod 600 ~/.ssh/known_hosts
          chmod 700 ~/.ssh

      - name: Deploy frontend dist
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SERVER_SSH_RSA }}
          DEPLOY_DIR: ${{ secrets.DEPLOY_FRONTEND_DIR }}
        run: |
          # 1. SSH 디렉토리 준비
          mkdir -p ~/.ssh

          # 2. 개인키 복원 (가장 안전한 Heredoc 방식)
          cat << 'EOF' > ./private_key
          ${{ secrets.SERVER_SSH_RSA }}
          EOF

          chmod 600 ./private_key

          # 3. 경로 정리 (혹시 모를 공백 제거)
          CLEAN_DIR=$(echo "$DEPLOY_DIR" | tr -d '\r\n')

          # 4. rsync 실행
          # 로컬에서 접속 성공한 환경과 동일하게 ED25519 키를 사용합니다.
          rsync -avz --delete \
            -e "ssh -p 22 -i ./private_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null" \
            artifacts/frontend/ \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:"$CLEAN_DIR/"

          # 5. 사용한 임시 키 삭제
          rm ./private_key

      - name: Rebuild & restart backend container
        run: |
          # 1. 키 파일 다시 생성 (앞선 스텝과 동일하게)
          cat << 'EOF' > ./private_key
          ${{ secrets.SERVER_SSH_RSA }}
          EOF
          chmod 600 ./private_key

          # 2. SSH 접속 후 명령 실행
          # -T 옵션을 추가하여 "Pseudo-terminal" 관련 경고를 방지합니다.
          ssh -i ./private_key -o StrictHostKeyChecking=no -T deploy@${{ secrets.SERVER_HOST }} << 'EOF'
            cd ${{ secrets.DEPLOY_BACKEND_DIR }}
            
            # 빌드 및 실행
            docker compose up -d --build            
            # 용량 관리
            docker image prune -f
            
            # Nginx 설정 반영 (비밀번호 없이 실행 가능해짐)
            sudo systemctl reload nginx
          EOF

          rm ./private_key

      - name: Docker Run
        run: |
          ssh -p ${{ secrets.SERVER_PORT }} ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << EOF
          cd ${{ secrets.DEPLOY_BACKEND_DIR }}
          docker compose up -d --build
          docker image prune -f  # 사용하지 않는 옛날 이미지 삭제 (용량 관리)
          sudo systemctl reload nginx
          EOF
